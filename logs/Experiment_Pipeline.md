## Preprocessing with IsoSeq3 pipeline   

### Section 1 - Preprocessing subreads.bam with BGI pipeline     
Raw PacBio Iso-Seq data in subreads.bam format were processed using a combination of the [BGI-Full-Length-RNA-Analysis-Pipeline](https://github.com/shizhuoxing/BGI-Full-Length-RNA-Analysis-Pipeline) and the official [PacBio IsoSeq3 pipeline](https://github.com/PacificBiosciences/IsoSeq).  Initially, each sequencing run was processed with ccs to generate HiFi reads (predicted accuracy ≥ Q20) using the parameters: min-passes 0, min-length 50, max-length 21000, and min-rq 0.75. This ensured that the resulting HiFi reads had at least 1 full-length subreads, lengths between 50 and 21000 bp, and a minimum read accuracy of 0.75.     

Primers were removed using in-house scripts from the BGI pipeline, with forward primer (5') sequence `AAGCAGTGGTATCAACGCAGAGTACATGGGGGGGG` and the reverse primer (3') sequence `GTACTCTGCGTTGATACCACTGCTTACTAGT`. These primers were mapped to the CCS reads using NCBI BLAST (version 2.11.1). The BLAST results were utilized by the classify_by_primer utility to identify full-length transcripts based on the BGI patented multi-transcripts approach. FLNC reads were generated with parameters: minimum UMI length of 8, minimum aligned primer length is 16, and minimum output transcript length without polyA tail is 200. The classify_by_primer.py script then performed the following tasks: (1) parsing 5’ and 3’ primers in CCS reads to obtain FLNC reads oriented from 5’ to 3’; (2) trimming the 5’ and 3’ primer sequences, including 28 bp following the 3’ primer; and (3) trimming the 3’ polyA tail using a sliding window algorithm. Subsequently, flnc.sam was created from ccs.sam and flnc.fasta using the flnc2sam function and converted to flnc.bam using Samtools. This completed the steps in the BGI pipeline, after which processing continued with the Iso-Seq3 pipeline.   

### Section 2 - Preprocessing isoseq_flnc.bam with IsoSeq3 pipeline      
#### Approach 1 – processing long read sequences separately      
Script: [preprocess.sh](/codes/preprocess.sh)      
For each individual long read sequence, `isoseq3 cluster2` function performs a clustering step beginning by clustering using hierarchical n•log(n) alignemnt and iterative cluater merging, followed by polishing POA sequence generation using a QV-guided consensus approach. The resulting output contains isoforms with at least 2 FLNC reads, all should have a predicted accuracy of ≥0.99, as HiFi reads were used as input.     

#### Approach 1 – processing long read sequences together     
Script: [preprocess_pooled.sh](/codes/preprocess_pooled.sh)    
To generate a single expression matrix for subsequent differential exon expression analysis, we need to generate one transcriptome for all sequenced samples, this is done by adding an additional step after `isoseq_flnc.bam` and before `isoseq3 cluster2` to merge the SMRT cells. Since we processed our `isoseq_flnc.bam` using customised BGI script, here we need to add read group information to these `isoseq_flnc.bam`. @RG and @HD are obtained by running the origianl PacBio IsoSeq3 `lima` on `ccs.bam` and `refine` on the `fl.bam` to produce a `new_flnc.bam` containing @RG, @HD, and @PG. Sample corresponded @RG and @HD are stripped from the `new_flnc.bam` using samtools and pasted to our BGI produced `isoseq_flnc.bam`. The paths of new `updated_isoseq_flnc.bam` from all samples are stored in a `output.fofn` file with each path separated by a line. This `output.fofn` file is then used in the `isoseq3 cluster2` function to call all long read samples and produce a single `clustered.bam` file.      

From `clustered.bam` onwards the pipeline remain the same, in short we employed Pigeon to classify full-length transcript isoforms against a reference annotation. Initially, the clustered .bam was mapped to hg38 reference genome using `pbmm2`. Redundant transcripts were then collapsed into unique isoforms based on exonic structures using `isoseq3 collapse`, ensuring not to collapse extra 5' exons, as bulk sequencing was performed. The genome annotation (gencode.v39.chr_patch_hapl_scaff.annotation.gtf), hg38.fasta, and the collapsed.gff from isoseq collapse were then sorted and indexed. The output collapsed.gff is then passed to SQANTI3 pipeline for quality control and isoform annotation.            

### Section 3 - Quality Control, Curation and Annotation of Long-read Transcripts using SQANTI3      
SQANTI3 is the newest version integrating functionalities from both SQANTI and SQANTI2. The core module, the quality control module, evaluates the de novo transcriptome against a reference annotation and outputs a classification file. The `sqanti3_qc.py` script takes in three compulsory files: (1) `collapsed.gff` from IsoSeq3, representing our sample transcript, (2) sorted and indexed Gencode v39 comprehensive annotation in .gtf format, and (3) hg38 fasta file used in IsoSeq3 pipeline. Optional files were supplied when possible, public reference files including polyA motifs, polyA peaks, public CAGE peak data, human TAPPAS Gencode v39 annotation and intropolis junctions were downloaded from SQANTI3 wiki page. Sample specific reference files including FLNC counts from IsoSeq3 pipeline and matched/pooled short reads fastq (R1/R2) were also provided when possible. Specifically, 18/25 samples have matched short reads and the other 7/25 used a pooled short read as reference. Alignment was carried out using minimap2.       

The output classification table consists of the following main categories of splicing events: full splice match (FSM), incomplete splice match (ISM), novel in category (NIC), novel not in catalog (NNC) and others (antisense, fusion, genic, genic intron, and intergenic). FSM is defined when reference and query isoform have the same exon count with same internal junction aligning to the reference. ISM is defined when query isoform have fewer outer exons compared to reference but still have all internal junctions aligned to reference. NIC is characterized by new combination of known, catalogued splice junctions (pairs of donor-acceptor sites) while NNC is very similar but have at least one splice site (donor or acceptor) entirely novel and uncatalogued before.    

We employed a customized filtering rule inspired by Veiga et al., (2022). Briefly, FSM: all retained; ISM: filtered out unreliable 3’end (if percentage of genomic A’s in the downstream 20bp window perc_A_dowmstreamTTS > 0.80); NIC: filtered out unreliable 3’end, intron-retention (in subcategory column), minimum coverage below 10; NNC: filtered out unreliable 3’end, intron-retention, junction labelled as RT-switch, minimum coverage below 10, and non-canonical splice sites; the rest of the splicing events are filtered out for intron-retention, junctions labelled as RT-switch, minimum coverage below 10, non-canonical splicing sites.      



